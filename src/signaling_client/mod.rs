use std::{
    fmt, io,
    net::{Shutdown, TcpStream},
    sync::{
        Arc, Mutex,
        mpsc::{self, Receiver, Sender},
    },
    thread,
};

use crate::{
    app::log_sink::LogSink,
    signaling::protocol::{self, FrameError, Msg},
    sink_error, sink_info,
};

/// Events generated by the background signaling connection.
#[derive(Debug)]
pub enum SignalingEvent {
    Connected,
    Disconnected,
    Error(String),
    ServerMsg(Msg),
}

/// Errors that can occur while sending signaling messages.
#[derive(Debug)]
pub enum SignalingClientError {
    Io(io::Error),
    Frame(FrameError),
    Poisoned,
    Disconnected,
}

impl fmt::Display for SignalingClientError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalingClientError::Io(e) => write!(f, "IO error: {e}"),
            SignalingClientError::Frame(e) => write!(f, "protocol error: {:?}", e),
            SignalingClientError::Poisoned => write!(f, "stream lock poisoned"),
            SignalingClientError::Disconnected => write!(f, "signaling client disconnected"),
        }
    }
}

impl std::error::Error for SignalingClientError {}

/// Thin client responsible for sending/receiving signaling messages.
pub struct SignalingClient {
    writer: Arc<Mutex<TcpStream>>,
    events: Receiver<SignalingEvent>,
    log: Arc<dyn LogSink>,
    connected: Arc<Mutex<bool>>,
}

impl SignalingClient {
    const CLIENT_VERSION: &'static str = "rustyrtc-gui-0.1";

    /// Connects to the signaling server and starts the background reader thread.
    pub fn connect(addr: &str, log: Arc<dyn LogSink>) -> io::Result<Self> {
        let stream = TcpStream::connect(addr)?;
        stream.set_nodelay(true).ok();
        let reader = stream.try_clone()?;
        let writer = Arc::new(Mutex::new(stream));
        let (tx, rx) = mpsc::channel::<SignalingEvent>();
        let connected = Arc::new(Mutex::new(true));

        {
            let mut guard = writer
                .lock()
                .map_err(|_| io::Error::new(io::ErrorKind::Other, "writer lock poisoned"))?;
            protocol::write_msg(
                &mut *guard,
                &Msg::Hello {
                    client_version: Self::CLIENT_VERSION.to_string(),
                },
            )
            .map_err(|err| {
                io::Error::new(io::ErrorKind::Other, format!("hello failed: {:?}", err))
            })?;
        }

        Self::spawn_reader_thread(
            addr.to_string(),
            reader,
            tx.clone(),
            Arc::clone(&connected),
            log.clone(),
        );

        Ok(Self {
            writer,
            events: rx,
            log,
            connected,
        })
    }

    fn spawn_reader_thread(
        addr: String,
        mut reader: TcpStream,
        tx: Sender<SignalingEvent>,
        connected: Arc<Mutex<bool>>,
        log: Arc<dyn LogSink>,
    ) {
        thread::spawn(move || {
            sink_info!(log, "[signaling_client] connected to {}", addr);
            let _ = tx.send(SignalingEvent::Connected);
            loop {
                match protocol::read_msg(&mut reader) {
                    Ok(msg) => {
                        if tx.send(SignalingEvent::ServerMsg(msg)).is_err() {
                            break;
                        }
                    }
                    Err(FrameError::Io(e)) => {
                        sink_error!(
                            log,
                            "[signaling_client] IO error from {}: {:?} ({:?})",
                            addr,
                            e,
                            e.kind()
                        );
                        let _ = tx.send(SignalingEvent::Error(e.to_string()));
                        break;
                    }
                    Err(FrameError::Proto(err)) => {
                        sink_error!(
                            log,
                            "[signaling_client] protocol error from {}: {:?}",
                            addr,
                            err
                        );
                        let _ =
                            tx.send(SignalingEvent::Error(format!("protocol error: {:?}", err)));
                        break;
                    }
                }
            }

            if let Ok(mut flag) = connected.lock() {
                *flag = false;
            }
            let _ = tx.send(SignalingEvent::Disconnected);
        });
    }

    /// Attempts to send a message to the server.
    pub fn send(&self, msg: Msg) -> Result<(), SignalingClientError> {
        if !self.is_connected() {
            return Err(SignalingClientError::Disconnected);
        }
        let mut guard = self
            .writer
            .lock()
            .map_err(|_| SignalingClientError::Poisoned)?;
        protocol::write_msg(&mut *guard, &msg).map_err(SignalingClientError::Frame)
    }

    /// Gracefully closes the TCP connection.
    pub fn disconnect(&self) {
        if let Ok(guard) = self.writer.lock() {
            let _ = guard.shutdown(Shutdown::Both);
        }
        if let Ok(mut flag) = self.connected.lock() {
            *flag = false;
        }
    }

    /// Polls the next pending event from the background thread.
    pub fn try_recv(&self) -> Option<SignalingEvent> {
        self.events.try_recv().ok()
    }

    fn is_connected(&self) -> bool {
        self.connected.lock().map(|f| *f).unwrap_or(false)
    }
}
