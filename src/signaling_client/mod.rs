use std::{
    fmt,
    io::{self, Read, Write},
    net::TcpStream,
    sync::{
        Arc,
        mpsc::{self, Receiver, Sender},
    },
    thread,
    time::{Duration, Instant},
};

use crate::{
    log::log_sink::LogSink,
    signaling::protocol::{self, FrameError, SignalingMsg},
    sink_debug, sink_error, sink_info, sink_trace, sink_warn,
};

use crate::signaling::tls::build_signaling_client_config;
use rustls::{ClientConfig, ClientConnection, StreamOwned, pki_types::ServerName};

/// Events generated by the background signaling connection.
#[derive(Debug)]
pub enum SignalingEvent {
    Connected,
    Disconnected,
    Error(String),
    ServerMsg(SignalingMsg),
}

/// Commands issued by the GUI / application into the signaling client.
#[derive(Debug)]
enum SignalingCommand {
    Send(SignalingMsg),
    Disconnect,
}

/// Errors that can occur while sending signaling messages.
///
/// In this design, the only thing `send()` can reliably report is that the
/// signaling client is disconnected (i.e. the network thread has exited and
/// dropped its command receiver).
#[derive(Debug)]
pub enum SignalingClientError {
    Io(io::Error),
    Frame(FrameError),
    Poisoned,
    Disconnected,
}

impl fmt::Display for SignalingClientError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalingClientError::Io(e) => write!(f, "IO error: {e}"),
            SignalingClientError::Frame(e) => write!(f, "protocol error: {:?}", e),
            SignalingClientError::Poisoned => write!(f, "stream lock poisoned"),
            SignalingClientError::Disconnected => write!(f, "signaling client disconnected"),
        }
    }
}

impl std::error::Error for SignalingClientError {}

/// Thin client responsible for sending/receiving signaling messages.
///
/// - Only the background thread touches the underlying stream (`TcpStream`,
///   TLS stream, etc.).
/// - The GUI sends `SignalingCommand`s in, and receives `SignalingEvent`s out.
pub struct SignalingClient {
    cmd_tx: Sender<SignalingCommand>,
    events: Receiver<SignalingEvent>,
}

impl SignalingClient {
    const CLIENT_VERSION: &'static str = "rustyrtc-gui-0.1";

    const PING_INTERVAL_SECS: u64 = 5;
    const TIMEOUT_SECS: u64 = 15;

    /// Build a rustls ClientConfig using the pinned mkcert CA.
    ///
    /// This trusts *only* the private CA we shipped with the app.
    pub fn default_tls_config() -> io::Result<Arc<ClientConfig>> {
        build_signaling_client_config()
    }

    /// Connects to the signaling server over plain TCP and starts the
    /// background network thread.
    ///
    /// This returns `Ok` as soon as the TCP connection is established and the
    /// network thread is spawned. Any later protocol/IO errors are reported via
    /// `SignalingEvent::Error` + `SignalingEvent::Disconnected`.
    pub fn connect(addr: &str, log: Arc<dyn LogSink>) -> io::Result<Self> {
        let stream = TcpStream::connect(addr)?;

        // Configure TCP specifics here (before we might wrap it in TLS in other ctors).
        if let Err(e) = stream.set_nodelay(true) {
            sink_warn!(
                log,
                "[signaling_client] set_nodelay failed for {}: {e:?}",
                addr
            );
        }
        if let Err(e) = stream.set_read_timeout(Some(Duration::from_millis(200))) {
            sink_warn!(
                log,
                "[signaling_client] set_read_timeout failed for {}: {e:?}",
                addr
            );
        }

        let (cmd_tx, cmd_rx) = mpsc::channel::<SignalingCommand>();
        let (ev_tx, ev_rx) = mpsc::channel::<SignalingEvent>();

        // Hand the raw TcpStream to the generic network thread.
        Self::spawn_network_thread(addr.to_string(), stream, cmd_rx, ev_tx, log);

        Ok(Self {
            cmd_tx,
            events: ev_rx,
        })
    }

    /// TLS-enabled constructor (using `rustls`).
    pub fn connect_tls(
        addr: &str,
        // DNS name used for TLS SNI / certificate verification
        domain: &str,
        tls_config: Arc<ClientConfig>,
        log: Arc<dyn LogSink>,
    ) -> io::Result<Self> {
        // 1) Establish and configure the underlying TCP socket.
        let tcp = TcpStream::connect(addr)?;
        if let Err(e) = tcp.set_nodelay(true) {
            sink_warn!(
                log,
                "[signaling_client] (tls) set_nodelay failed for {}: {e:?}",
                addr
            );
        }
        if let Err(e) = tcp.set_read_timeout(Some(Duration::from_millis(200))) {
            sink_warn!(
                log,
                "[signaling_client] (tls) set_read_timeout failed for {}: {e:?}",
                addr
            );
        }

        // 2) Build the rustls client connection.
        let server_name = ServerName::try_from(domain.to_owned())
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidInput, "invalid DNS name"))?;

        let conn = ClientConnection::new(tls_config, server_name)
            .map_err(|e| io::Error::other(format!("TLS error: {e}")))?;

        // 3) Wrap TCP + TLS into a single stream that implements Read + Write.
        let tls_stream = StreamOwned::new(conn, tcp);

        let (cmd_tx, cmd_rx) = mpsc::channel::<SignalingCommand>();
        let (ev_tx, ev_rx) = mpsc::channel::<SignalingEvent>();

        // 4) Reuse the same generic network thread.
        Self::spawn_network_thread(format!("tls://{}", addr), tls_stream, cmd_rx, ev_tx, log);

        Ok(Self {
            cmd_tx,
            events: ev_rx,
        })
    }

    /// Background network thread: owns the stream (TCP or TLS), handles:
    /// - Hello
    /// - Reads incoming messages
    /// - Processes commands (Send/Disconnect)
    /// - Sends periodic Ping and enforces heartbeat timeout
    fn spawn_network_thread<S>(
        addr: String,
        mut stream: S,
        cmd_rx: Receiver<SignalingCommand>,
        ev_tx: Sender<SignalingEvent>,
        log: Arc<dyn LogSink>,
    ) where
        S: Read + Write + Send + 'static,
    {
        thread::spawn(move || {
            // Initial Hello
            sink_debug!(log, "[signaling_client] sending Hello to {}", addr);
            if let Err(err) = protocol::write_msg(
                &mut stream,
                &SignalingMsg::Hello {
                    client_version: Self::CLIENT_VERSION.to_string(),
                },
            ) {
                sink_error!(
                    log,
                    "[signaling_client] hello failed to {}: {:?}",
                    addr,
                    err
                );
                let _ = ev_tx.send(SignalingEvent::Error(format!("hello failed: {:?}", err)));
                let _ = ev_tx.send(SignalingEvent::Disconnected);
                return;
            }

            sink_info!(log, "[signaling_client] connected to {}", addr);
            let _ = ev_tx.send(SignalingEvent::Connected);

            // Heartbeat state
            let ping_interval = Duration::from_secs(Self::PING_INTERVAL_SECS);
            let timeout = Duration::from_secs(Self::TIMEOUT_SECS);
            let mut last_seen = Instant::now();
            let mut next_ping = Instant::now() + ping_interval;
            let mut nonce: u64 = 1;

            loop {
                // 1) Drain commands from the GUI.
                let mut disconnect_requested = false;
                loop {
                    match cmd_rx.try_recv() {
                        Ok(SignalingCommand::Send(msg)) => {
                            sink_debug!(log, "[signaling_client] send {:?}", msg_name(&msg));
                            if let Err(e) = protocol::write_msg(&mut stream, &msg) {
                                match e {
                                    FrameError::Io(ioe) => {
                                        sink_error!(
                                            log,
                                            "[signaling_client] IO error while sending to {}: {:?} ({:?})",
                                            addr,
                                            ioe,
                                            ioe.kind()
                                        );
                                        let _ = ev_tx.send(SignalingEvent::Error(ioe.to_string()));
                                    }
                                    FrameError::Proto(err) => {
                                        sink_error!(
                                            log,
                                            "[signaling_client] protocol error while sending to {}: {:?}",
                                            addr,
                                            err
                                        );
                                        let _ = ev_tx.send(SignalingEvent::Error(format!(
                                            "protocol error: {:?}",
                                            err
                                        )));
                                    }
                                }
                                disconnect_requested = true;
                                break;
                            }
                        }
                        Ok(SignalingCommand::Disconnect) => {
                            sink_info!(log, "[signaling_client] disconnect requested by client");
                            disconnect_requested = true;
                            break;
                        }
                        Err(mpsc::TryRecvError::Empty) => break,
                        Err(mpsc::TryRecvError::Disconnected) => {
                            sink_info!(
                                log,
                                "[signaling_client] command channel closed, shutting down"
                            );
                            disconnect_requested = true;
                            break;
                        }
                    }
                }

                if disconnect_requested {
                    break;
                }

                // 2) Try to read a message.
                //
                // For TCP we rely on `set_read_timeout` configured by the constructor.
                // For TLS, the underlying TCP's timeout still applies to `read()`.
                match protocol::read_msg(&mut stream) {
                    Ok(msg) => {
                        last_seen = Instant::now();
                        sink_debug!(log, "[signaling_client] recv {:?}", msg_name(&msg));
                        if ev_tx.send(SignalingEvent::ServerMsg(msg)).is_err() {
                            sink_warn!(
                                log,
                                "[signaling_client] events receiver dropped, shutting down"
                            );
                            break;
                        }
                    }
                    Err(FrameError::Io(ref e))
                        if e.kind() == io::ErrorKind::TimedOut
                            || e.kind() == io::ErrorKind::WouldBlock
                            || e.kind() == io::ErrorKind::Interrupted =>
                    {
                        // Timed out waiting for data â†’ not fatal, just continue.
                    }
                    Err(FrameError::Io(e)) => {
                        sink_error!(
                            log,
                            "[signaling_client] IO error from {}: {:?} ({:?})",
                            addr,
                            e,
                            e.kind()
                        );
                        let _ = ev_tx.send(SignalingEvent::Error(e.to_string()));
                        break;
                    }
                    Err(FrameError::Proto(err)) => {
                        sink_error!(
                            log,
                            "[signaling_client] protocol error from {}: {:?}",
                            addr,
                            err
                        );
                        let _ =
                            ev_tx.send(SignalingEvent::Error(format!("protocol error: {:?}", err)));
                        break;
                    }
                }

                // 3) Heartbeat / Ping.
                let now = Instant::now();
                let idle = now.duration_since(last_seen);

                if idle > timeout {
                    sink_error!(
                        log,
                        "[signaling_client] heartbeat timed out after {:?} to {}",
                        idle,
                        addr
                    );
                    let _ = ev_tx.send(SignalingEvent::Error("signaling heartbeat timeout".into()));
                    break;
                }

                if now >= next_ping {
                    let ping_msg = SignalingMsg::Ping { nonce };
                    if let Err(e) = protocol::write_msg(&mut stream, &ping_msg) {
                        match e {
                            FrameError::Io(ioe) => {
                                sink_error!(
                                    log,
                                    "[signaling_client] failed to send Ping to {}: {:?} ({:?})",
                                    addr,
                                    ioe,
                                    ioe.kind()
                                );
                                let _ = ev_tx.send(SignalingEvent::Error(ioe.to_string()));
                            }
                            FrameError::Proto(err) => {
                                sink_error!(
                                    log,
                                    "[signaling_client] protocol error while sending Ping to {}: {:?}",
                                    addr,
                                    err
                                );
                                let _ = ev_tx.send(SignalingEvent::Error(format!(
                                    "protocol error: {:?}",
                                    err
                                )));
                            }
                        }
                        break;
                    } else {
                        sink_trace!(
                            log,
                            "[signaling_client] sent Ping {} to {} (idle {:?})",
                            nonce,
                            addr,
                            idle
                        );
                    }
                    nonce = nonce.wrapping_add(1);
                    next_ping = now + ping_interval;
                }

                // 4) Small sleep to avoid busy-spinning when idle.
                thread::sleep(Duration::from_millis(10));
            }

            // Dropping `stream` closes the underlying connection (TCP or TLS).
            let _ = ev_tx.send(SignalingEvent::Disconnected);
        });
    }

    /// Attempts to send a message to the server (enqueue on the command channel).
    ///
    /// Note: actual IO happens in the network thread; any IO/protocol errors
    /// will be reported asynchronously as `SignalingEvent::Error`. From here we
    /// can only tell if the client is already disconnected.
    pub fn send(&self, msg: SignalingMsg) -> Result<(), SignalingClientError> {
        self.cmd_tx
            .send(SignalingCommand::Send(msg))
            .map_err(|_| SignalingClientError::Disconnected)
    }

    /// Gracefully closes the connection.
    ///
    /// If the network thread is already gone, this will just fail silently.
    pub fn disconnect(&self) {
        let _ = self.cmd_tx.send(SignalingCommand::Disconnect);
    }

    /// Polls the next pending event from the background thread.
    pub fn try_recv(&self) -> Option<SignalingEvent> {
        self.events.try_recv().ok()
    }
}

fn msg_name(msg: &SignalingMsg) -> &'static str {
    use SignalingMsg::*;
    match msg {
        Hello { .. } => "Hello",
        Login { .. } => "Login",
        LoginOk { .. } => "LoginOk",
        LoginErr { .. } => "LoginErr",
        Register { .. } => "Register",
        RegisterOk { .. } => "RegisterOk",
        RegisterErr { .. } => "RegisterErr",
        ListPeers => "ListPeers",
        PeersOnline { .. } => "PeersOnline",
        CreateSession { .. } => "CreateSession",
        Created { .. } => "Created",
        Join { .. } => "Join",
        JoinOk { .. } => "JoinOk",
        JoinErr { .. } => "JoinErr",
        PeerJoined { .. } => "PeerJoined",
        PeerLeft { .. } => "PeerLeft",
        Offer { .. } => "Offer",
        Answer { .. } => "Answer",
        Candidate { .. } => "Candidate",
        Ack { .. } => "Ack",
        Bye { .. } => "Bye",
        Ping { .. } => "Ping",
        Pong { .. } => "Pong",
    }
}
