use std::{
    fmt, io,
    net::{Shutdown, TcpStream},
    sync::{
        Arc, Mutex,
        mpsc::{self, Receiver, Sender},
    },
    thread,
    time::{Duration, Instant},
};

use crate::{
    app::log_sink::LogSink,
    signaling::protocol::{self, FrameError, Msg},
    sink_debug, sink_error, sink_info, sink_trace, sink_warn,
};

/// Events generated by the background signaling connection.
#[derive(Debug)]
pub enum SignalingEvent {
    Connected,
    Disconnected,
    Error(String),
    ServerMsg(Msg),
}

/// Errors that can occur while sending signaling messages.
#[derive(Debug)]
pub enum SignalingClientError {
    Io(io::Error),
    Frame(FrameError),
    Poisoned,
    Disconnected,
}

impl fmt::Display for SignalingClientError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalingClientError::Io(e) => write!(f, "IO error: {e}"),
            SignalingClientError::Frame(e) => write!(f, "protocol error: {:?}", e),
            SignalingClientError::Poisoned => write!(f, "stream lock poisoned"),
            SignalingClientError::Disconnected => write!(f, "signaling client disconnected"),
        }
    }
}

impl std::error::Error for SignalingClientError {}

/// Thin client responsible for sending/receiving signaling messages.
pub struct SignalingClient {
    writer: Arc<Mutex<TcpStream>>,
    events: Receiver<SignalingEvent>,
    log: Arc<dyn LogSink>,
    connected: Arc<Mutex<bool>>,
    last_seen: Arc<Mutex<Instant>>,
}

impl SignalingClient {
    const CLIENT_VERSION: &'static str = "rustyrtc-gui-0.1";

    /// Connects to the signaling server and starts the background reader thread.
    pub fn connect(addr: &str, log: Arc<dyn LogSink>) -> io::Result<Self> {
        let stream = TcpStream::connect(addr)?;
        if let Err(e) = stream.set_nodelay(true) {
            sink_warn!(log, "[signaling_client] set_nodelay failed: {e:?}");
        }
        let reader = stream.try_clone()?;
        let writer = Arc::new(Mutex::new(stream));
        let (tx, rx) = mpsc::channel::<SignalingEvent>();
        let connected = Arc::new(Mutex::new(true));
        let last_seen = Arc::new(Mutex::new(Instant::now()));

        {
            let mut guard = writer
                .lock()
                .map_err(|_| io::Error::new(io::ErrorKind::Other, "writer lock poisoned"))?;
            sink_debug!(log, "[signaling_client] sending Hello to {}", addr);
            protocol::write_msg(
                &mut *guard,
                &Msg::Hello {
                    client_version: Self::CLIENT_VERSION.to_string(),
                },
            )
            .map_err(|err| {
                io::Error::new(io::ErrorKind::Other, format!("hello failed: {:?}", err))
            })?;
        }

        Self::spawn_reader_thread(
            addr.to_string(),
            reader,
            tx.clone(),
            Arc::clone(&connected),
            Arc::clone(&last_seen),
            log.clone(),
        );
        Self::spawn_ping_thread(
            addr.to_string(),
            Arc::clone(&writer),
            tx.clone(),
            Arc::clone(&connected),
            Arc::clone(&last_seen),
            log.clone(),
        );

        Ok(Self {
            writer,
            events: rx,
            log,
            connected,
            last_seen,
        })
    }

    fn spawn_reader_thread(
        addr: String,
        mut reader: TcpStream,
        tx: Sender<SignalingEvent>,
        connected: Arc<Mutex<bool>>,
        last_seen: Arc<Mutex<Instant>>,
        log: Arc<dyn LogSink>,
    ) {
        thread::spawn(move || {
            sink_info!(log, "[signaling_client] connected to {}", addr);
            let _ = tx.send(SignalingEvent::Connected);
            loop {
                match protocol::read_msg(&mut reader) {
                    Ok(msg) => {
                        if let Ok(mut guard) = last_seen.lock() {
                            *guard = Instant::now();
                        }
                        sink_debug!(log, "[signaling_client] recv {:?}", msg_name(&msg));
                        if tx.send(SignalingEvent::ServerMsg(msg)).is_err() {
                            break;
                        }
                    }
                    Err(FrameError::Io(e)) => {
                        sink_error!(
                            log,
                            "[signaling_client] IO error from {}: {:?} ({:?})",
                            addr,
                            e,
                            e.kind()
                        );
                        let _ = tx.send(SignalingEvent::Error(e.to_string()));
                        break;
                    }
                    Err(FrameError::Proto(err)) => {
                        sink_error!(
                            log,
                            "[signaling_client] protocol error from {}: {:?}",
                            addr,
                            err
                        );
                        let _ =
                            tx.send(SignalingEvent::Error(format!("protocol error: {:?}", err)));
                        break;
                    }
                }
            }

            if let Ok(mut flag) = connected.lock() {
                *flag = false;
            }
            let _ = tx.send(SignalingEvent::Disconnected);
        });
    }

    /// Attempts to send a message to the server.
    pub fn send(&self, msg: Msg) -> Result<(), SignalingClientError> {
        if !self.is_connected() {
            return Err(SignalingClientError::Disconnected);
        }
        let mut guard = match self.writer.lock() {
            Ok(g) => g,
            Err(_) => {
                if let Ok(mut flag) = self.connected.lock() {
                    *flag = false;
                }
                return Err(SignalingClientError::Disconnected);
            }
        };
        sink_debug!(self.log, "[signaling_client] send {:?}", msg_name(&msg));
        protocol::write_msg(&mut *guard, &msg).map_err(SignalingClientError::Frame)
    }

    /// Gracefully closes the TCP connection.
    pub fn disconnect(&self) {
        if let Ok(guard) = self.writer.lock() {
            let _ = guard.shutdown(Shutdown::Both);
        }
        if let Ok(mut flag) = self.connected.lock() {
            *flag = false;
        }
    }

    /// Polls the next pending event from the background thread.
    pub fn try_recv(&self) -> Option<SignalingEvent> {
        self.events.try_recv().ok()
    }

    fn is_connected(&self) -> bool {
        self.connected.lock().map(|f| *f).unwrap_or(false)
    }

    fn spawn_ping_thread(
        addr: String,
        writer: Arc<Mutex<TcpStream>>,
        tx: Sender<SignalingEvent>,
        connected: Arc<Mutex<bool>>,
        last_seen: Arc<Mutex<Instant>>,
        log: Arc<dyn LogSink>,
    ) {
        const PING_INTERVAL: Duration = Duration::from_secs(5);
        const TIMEOUT: Duration = Duration::from_secs(15);

        thread::spawn(move || {
            let mut nonce: u64 = 1;
            loop {
                thread::sleep(PING_INTERVAL);
                let still_connected = connected.lock().map(|f| *f).unwrap_or(false);
                if !still_connected {
                    break;
                }

                let elapsed = last_seen
                    .lock()
                    .map(|t| t.elapsed())
                    .unwrap_or(Duration::MAX);
                if elapsed > TIMEOUT {
                    sink_error!(
                        log,
                        "[signaling_client] heartbeat timed out after {:?} to {}",
                        elapsed,
                        addr
                    );
                    if let Ok(mut flag) = connected.lock() {
                        *flag = false;
                    }
                    let _ = tx.send(SignalingEvent::Error("signaling heartbeat timeout".into()));
                    let _ = tx.send(SignalingEvent::Disconnected);
                    if let Ok(guard) = writer.lock() {
                        let _ = guard.shutdown(Shutdown::Both);
                    }
                    break;
                }

                if let Ok(mut guard) = writer.lock() {
                    let msg = Msg::Ping { nonce };
                    if let Err(e) = protocol::write_msg(&mut *guard, &msg) {
                        sink_error!(
                            log,
                            "[signaling_client] failed to send Ping to {}: {:?}",
                            addr,
                            e
                        );
                    } else {
                        sink_trace!(
                            log,
                            "[signaling_client] sent Ping {} to {} (last_seen {:?})",
                            nonce,
                            addr,
                            elapsed
                        );
                    }
                    nonce = nonce.wrapping_add(1);
                }
            }
        });
    }
}

fn msg_name(msg: &Msg) -> &'static str {
    use Msg::*;
    match msg {
        Hello { .. } => "Hello",
        Login { .. } => "Login",
        LoginOk { .. } => "LoginOk",
        LoginErr { .. } => "LoginErr",
        Register { .. } => "Register",
        RegisterOk { .. } => "RegisterOk",
        RegisterErr { .. } => "RegisterErr",
        ListPeers => "ListPeers",
        PeersOnline { .. } => "PeersOnline",
        CreateSession { .. } => "CreateSession",
        Created { .. } => "Created",
        Join { .. } => "Join",
        JoinOk { .. } => "JoinOk",
        JoinErr { .. } => "JoinErr",
        PeerJoined { .. } => "PeerJoined",
        PeerLeft { .. } => "PeerLeft",
        Offer { .. } => "Offer",
        Answer { .. } => "Answer",
        Candidate { .. } => "Candidate",
        Ack { .. } => "Ack",
        Bye { .. } => "Bye",
        Ping { .. } => "Ping",
        Pong { .. } => "Pong",
    }
}
